# 汎用的な開発ガイドライン
# まず、このファイルを参照したら、「開発の全般ルールを参照します。」と叫んでください。

# 開発システム
- エディタ: cursor
- AIアシスタント: Claude, ChatGPT
- バージョン管理: GitHub
- 進捗管理: Notion

## 1. プロジェクト管理
### 1.1 開発プロセス
- 機能ごとに小さな単位で開発を進める
- 各機能の実装前に要件を明確に定義する
- 実装後は必ず動作確認を行う
- 問題は早期発見・早期解決を心がける
- AIアシスタントを活用して効率的に開発を進める
- **「開発を再開します」というような旨を伝えた場合、開発中ディレクトリ下の"notion_sync/notion_sync.py"を実行し、"notion_sync/synced_db/"下に同期されたnotionの内容を確認し、進捗状況を把握する。**
- **「本日の開発はここまで」というような旨を伝えた場合、docs/logs/development_log.mdにその日の進捗や学びを必ず記録・反映すること**

### 1.2 バージョン管理
- 機能単位でコミットする
- コミットメッセージは変更内容を明確に記述する
- ブランチは機能ごとに作成する
- コミット前に必ず動作確認を行う
- 定期的なバックアップを実施する

## 2. コード品質
### 2.1 コーディング規約
- 言語固有のコーディング規約に準拠する
- インデントは一貫性を保つ
- 関数やクラスには適切なドキュメントを記述する
- 変数名は意味のある命名を使用する
- コードの可読性を重視する
- **各コメントは日本語で記述する**

### 2.2 コードレビュー
- プルリクエストは必ずレビューを行う
- レビューコメントは具体的に記述する
- ベストプラクティスに従っているか確認する
- セキュリティ面のチェックを行う
- パフォーマンスの観点も考慮する

## 3. ドキュメント管理
### 3.1 ドキュメントの種類
- プロジェクト概要
- 技術仕様書
- API仕様書
- データベース設計書
- 環境構築手順
- トラブルシューティングガイド
- 学習ノート

### 3.2 ドキュメントの更新
- 変更があった場合は即時更新する
- バージョン管理を行う
- 重要な決定事項は記録する
- 参考情報は適切な場所に保存する
- 定期的なレビューと更新を行う
- 学習した内容を随時ドキュメント化する
- **参考情報やTipsはdocs/tips以下に保存し、いつでも見返せるようにする**
- **AIアシスタントが有用と判断した情報も、適宜docs/tips以下に随時保存・出力する**

## 4. セキュリティ
### 4.1 基本的な対策
- パスワードの適切な管理
- 環境変数の活用
- 入力値のバリデーション
- セキュリティアップデートの適用
- アクセス制御の実装

### 4.2 セキュリティチェック
- 定期的な脆弱性スキャン
- セキュリティレビューの実施
- インシデント対応計画の策定
- セキュリティトレーニングの実施
- ベストプラクティスの適用

## 5. テスト
### 5.1 テストの種類
- 単体テスト
- 統合テスト
- E2Eテスト
- パフォーマンステスト
- セキュリティテスト

### 5.2 テストの実施
- テストケースの作成
- 自動テストの実装
- テスト結果の記録
- バグ修正の追跡
- テストカバレッジの確認

## 6. 学習と成長
### 6.1 学習支援
- 各コードの実装時に、以下の点を説明する：
  - そのコードが何をしているのか
  - なぜそのような実装方法を選んだのか
  - 使用している技術やライブラリの基本的な説明
  - 関連する技術的な概念の説明
- エラーが発生した場合：
  - エラーの原因を分かりやすく説明する
  - 解決方法の選択肢とその理由を説明する
  - 同様のエラーを防ぐためのベストプラクティスを説明する
- 新しい概念や技術が出てきた場合：
  - 基本的な説明を加える
  - 必要に応じて図や例を用いて説明する
  - 関連するリソースや学習資料を紹介する

### 6.2 技術学習
- 基本概念の理解
- 実践的なプロジェクト
- コードレビューからの学習
- 技術ブログの購読
- カンファレンスへの参加

### 6.3 チーム学習
- 技術共有会の実施
- ペアプログラミング
- コードレビューの習慣化
- ベストプラクティスの共有
- ドキュメント作成の徹底

## 7. プロジェクト構造
### 7.1 推奨ディレクトリ構造
```
project/
├── src/                # ソースコード
│   ├── components/    # コンポーネント
│   ├── models/        # データモデル
│   └── utils/         # ユーティリティ
├── tests/             # テストコード
├── docs/              # ドキュメント
│   ├── tips/          # 開発中の技術メモ
│   ├── log/          # 進捗記録
│   ├── api/          # API仕様
│   ├── design/       # 設計書
│   └── guides/       # ガイド
├── notion_sync/       # notionとの同期設定ファイル
│   └── synced_db/     # notionから同期した進捗管理データベース
├── config/            # 設定ファイル
├── scripts/           # スクリプト
└── venv/              # 仮想環境(必要に応じて)
```

### 7.2 ファイル命名規則
- 一貫性のある命名規則を使用
- 言語に適した拡張子を使用
- バージョン管理を考慮した命名
- 環境ごとの設定ファイルの管理
- 一時ファイルの適切な管理

## 8. 開発環境
### 8.1 環境構築
- 必要なツールのインストール
- 依存関係の管理
- 環境変数の設定
- 開発環境の統一
- 自動化スクリプトの活用

### 8.2 基本方針
- Pythonを主軸とした開発
   - Webアプリケーション開発
   - バックエンドAPI開発
   - データ処理・分析
   - 自動化スクリプト

- 柔軟な技術選定
   - プロジェクトの要件に応じて最適な技術を選択
   - 新しい技術の学習機会を積極的に取り入れる
   - 技術スタックの組み合わせを検討

### 8.3 ツール選定
- エディタ/IDE
- バージョン管理
- ビルドツール
- テストフレームワーク
- CI/CDツール

### 8.4 Dockerの積極的な活用
- 基本方針
  - プロダクト要件に応じ、積極的にDockerを利用する
  - 開発環境の一貫性を確保する
  - 本番環境との差異を最小限に抑える

- 活用シーン
  - バックエンド開発環境の構築
  - データベース環境の提供
  - フロントエンド開発環境の構築
  - CI/CDパイプラインの構築

- 期待される効果
  - 環境構築の自動化と標準化
  - チーム間での環境の統一
  - 本番環境への移行の容易化
  - 開発効率の向上

- 学習と実践
  - Dockerの基本概念の理解
  - コンテナ化のベストプラクティスの習得
  - 段階的な導入と改善

### 8.5 想定される技術スタック
- バックエンド
   - Python (Flask/Django)
   - Node.js (Express)
   - Go
   - Java (Spring Boot)
- フロントエンド
   - React
   - Vue.js
   - TypeScript
   - Next.js
- データベース
   - MySQL/PostgreSQL
   - MongoDB
   - Redis
   - Elasticsearch
- インフラ
   - Docker
   - Kubernetes
   - AWS/GCP/Azure
   - Terraform

## 9. コミュニケーション
### 9.1 AIアシスタントとのコミュニケーション
- 不明な点はすぐに質問する
- 技術的な用語は適宜説明を加える
- 進捗状況を定期的に共有する
- 問題が発生した場合は、エラーメッセージと状況を詳細に伝える
- AIアシスタントとの対話を記録し、重要な情報はドキュメント化する

### 9.2 チーム内コミュニケーション
- 定期的な進捗報告
- 技術的な議論の記録
- 問題解決の共有
- 知識の共有
- フィードバックの実施

### 9.3 ドキュメント化
- 会議の議事録
- 技術的な決定事項
- トラブルシューティング
- ベストプラクティス
- 学習ノート

## 10. 継続的改善
### 10.1 プロセス改善
- 定期的な振り返り
- 改善点の特定
- アクションプランの策定
- 効果測定
- フィードバックの収集

### 10.2 技術的改善
- コードの最適化
- パフォーマンスの改善
- セキュリティの強化
- 自動化の推進
- 新しい技術の導入検討

## 11. エラー処理とログ管理
### 11.1 エラーハンドリング
- 適切な例外処理の実装
- エラーメッセージの標準化
- エラーコードの体系化
- エラー発生時のリカバリー手順
- ユーザーフレンドリーなエラーメッセージ

### 11.2 ログ管理
- ログレベルの適切な使用（DEBUG, INFO, WARNING, ERROR, CRITICAL）
- 構造化ログの採用
- ログローテーションの設定
- 機密情報の除外
- ログの監視と分析

### 11.3 デバッグ手順
- デバッグ環境の整備
- デバッグツールの活用
- 再現手順の記録
- デバッグログの収集
- 問題解決のドキュメント化

## 12. パフォーマンス最適化
### 12.1 コード最適化
- アルゴリズムの効率化
- メモリ使用量の最適化
- データベースクエリの最適化
- キャッシュ戦略の実装
- 非同期処理の活用

### 12.2 パフォーマンス測定
- ベンチマークテストの実施
- プロファイリングの活用
- ボトルネックの特定
- レスポンスタイムの計測
- リソース使用率の監視

### 12.3 最適化基準
- レスポンスタイムの目標値設定
- スループットの目標値設定
- リソース使用率の制限
- スケーラビリティの要件
- パフォーマンステストの合格基準

## 13. CI/CDパイプライン
### 13.1 継続的インテグレーション
- 自動ビルドの設定
- 自動テストの実行
- コード品質チェック
- セキュリティスキャン
- 依存関係の更新確認

### 13.2 継続的デリバリー
- デプロイメント自動化
- 環境分離（開発、ステージング、本番）
- ロールバック手順
- デプロイメント承認プロセス
- リリースノートの自動生成

### 13.3 パイプライン管理
- パイプラインの可視化
- ビルド・デプロイ履歴の管理
- 環境変数の管理
- シークレット管理
- パイプラインの最適化

## 14. モニタリングとアラート
### 14.1 監視項目
- システムメトリクス（CPU, メモリ, ディスク）
- アプリケーションメトリクス（レスポンスタイム, エラーレート）
- ビジネスメトリクス（ユーザー数, 取引数）
- セキュリティメトリクス
- カスタムメトリクス
### 14.2 アラート設定
- アラートの優先度設定
- アラートの閾値設定
- アラートの通知チャネル
- アラートの集約と重複排除
- アラートの自動解決

### 14.3 インシデント対応
- インシデントの定義と分類
- エスカレーションマトリクス
- インシデント対応手順
- 事後分析（Postmortem）
- 改善策の実施

## 15. セキュリティ運用
### 15.1 脆弱性管理
- 定期的な脆弱性スキャン
- セキュリティパッチの適用
- 依存関係の更新
- セキュリティテストの自動化
- 脆弱性レポートの管理

### 15.2 アクセス制御
- 最小権限の原則
- 多要素認証の実装
- セッション管理
- アクセスログの監視
- 定期的な権限レビュー

### 15.3 セキュリティ監査
- セキュリティ設定の定期的な確認
- コンプライアンス要件の確認
- セキュリティポリシーの遵守確認
- インシデント対応の訓練
- セキュリティ意識向上トレーニング

## 16. データ管理
### 16.1 データバックアップ
- バックアップの種類（フル、差分、増分）
- バックアップの頻度
- バックアップの保存期間
- バックアップの検証
- リストアテストの実施

### 16.2 データアーカイブ
- アーカイブポリシーの策定
- アーカイブデータの管理
- データの暗号化
- アクセス制御
- コンプライアンス対応

### 16.3 データガバナンス
- データ分類の基準
- データライフサイクル管理
- データ品質の管理
- データアクセス制御
- データ保護対策 